GC的演化首先是效率或者说性能的提升，从串行到并行，然后是GC跟业务程序资源的平衡，在尽可能减少业务影响的前提下，分配部分资源给到GC，并减少STW的时间，并行GC到CMSGC。  
###串行GC(-XX:+UseSerialGC)
串行GC主要就是在年轻代和老年代都使用单线程进行垃圾回收，节省了多线程交互的消耗，但是也没法利用多核处理器的优势，适用于数据量小、单核/少核处理器或者是Client模式的情况。
串行GC的“单线程”也意味着在垃圾回收时，其他工作线程也必须暂停等到垃圾回收结束，即STW（Stop The World），所以STW的时间较长，串行GC是JDK1.3.1之前的年轻代GC的唯一选择。
年轻代使用复制算法、老年代使用标记-整理算法，都要STW。
###并行GC(-XX:+UseParallelGC)

###CMSGC(-XX:+UseConcMarkSweepGC)

###G1GC(-xx:+UseG1GC)
