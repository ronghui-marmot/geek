GC的演化首先是效率或者说性能的提升，从串行到并行，然后是GC跟业务程序资源的平衡，在尽可能减少业务影响的前提下，分配部分资源给到GC，并减少STW的时间，并行GC到CMSGC。  
### 串行GC(-XX:+UseSerialGC)  
- 串行GC主要就是在年轻代和老年代都使用单线程进行垃圾回收，节省了多线程交互的消耗，但是也没法利用多核处理器的优势，适用于数据量小、单核/少核处理器或者是Client模式的情况。
- 串行GC的“单线程”也意味着在垃圾回收时，其他工作线程也必须暂停等到垃圾回收结束，即STW（Stop The World），所以STW的时间较长，串行GC是JDK1.3.1之前的年轻代GC的唯一选择。
- 年轻代使用标记-复制算法、老年代使用标记-清除-整理算法，都要STW。
### 并行GC(-XX:+UseParallelGC)  
- 并行GC是在串行GC的基础上，使用多线程进行年轻代的垃圾回收，适用于多核处理器或者Server模式。
- 并行GC是使用CMSGC的默认年轻代GC，通过-XX:ParallelGCThreads=？设置并行垃圾回收的线程数，-XX:MaxGCPauseMillis=？设置每次停顿的最长时间。
- 年轻代使用标记-复制算法、老年代使用标记-清除-整理算法，年轻代和老年代的GC仍然会STW
### CMSGC(-XX:+UseConcMarkSweepGC) 
- CMSGC是以获取最短回收停顿时间为目标，适用于互联网站或者是B/S模式的服务端上，缺点是CMS基于“标记-清除”算法，会使得GC结束时产生大量空间碎片，可能引起大对象分配失败，触发Full GC。   
- CMSGC默认启动的线程数为(CPU数量+3)/4， -XX:CMSInitiatingOccupancyFraction设置GC触发百分比，JDK1.6后，CMS的启动阈值默认为92%。  
- CMSGC的年轻代默认使用并行GC，老年代分为五个步骤，初始标记-并发标记-并发预清理-最终标记-并发清除-重置，其中初始标记和最终标记会引起STW
### G1GC(-xx:+UseG1GC)  
- G1GC将堆内存划分为多个大小相等的区域（Region），年轻代和老年代是一部分Region的集合，能充分应用多CPU、多核的优势，适用于服务端应用。
- XX：G1NewSizePercent初始年轻代占整个堆的比例，默认5%,-XX：G1MaxNewSizePercent最大年轻代占整个堆的比例，默认60%  
- G1GC主要分为四个步骤，初始标记-Root区扫描-并发标记-再次标记-清理，初始标记、再次标记和清理都会引起STW